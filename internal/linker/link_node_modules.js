/**
 * @fileoverview Creates a node_modules directory in the current working directory
 * and symlinks in the node modules needed to run a program.
 * This replaces the need for custom module resolution logic inside the process.
 */
const fs = require('fs');
const path = require('path');

const VERBOSE_LOGS = !!process.env['VERBOSE_LOGS'];

function log_verbose(...m) {
  if (!!process.env['VERBOSE_LOGS']) console.error('[link_node_modules.js]', ...m);
}

function log_ls_r(d) {
  if (VERBOSE_LOGS) {
    for (const p of fs.readdirSync(d)) {
      const f = path.join(d, p);
      log_verbose('  ', f);
      if (fs.statSync(f).isDirectory()) {
        log_ls_r(f);
      }
    }
  }
}

function symlink(target, path) {
  log_verbose(`symlink( ${path} -> ${target} )`);
  fs.symlinkSync(target, path);
}

function main(args) {
  if (!args || args.length < 1)
    throw new Error('link_node_modules.js requires one argument: modulesManifest path');

  const [modulesManifest] = args;
  let {root, modules} = JSON.parse(fs.readFileSync(modulesManifest));
  modules = modules || {};
  log_verbose(
      'read module manifest, node_modules root is', root, 'with first-party packages', modules);

  // First, symlink from a local `$PWD/node_modules` directory to the root of the third-party
  // installed node_modules (or create a node_modules directory if no root)

  if (!!root) {
    // Account for Bazel --legacy_external_runfiles
    if (fs.existsSync(path.join('external', root))) {
      log_verbose('found legacy_external_runfiles, switching root to', path.join('external', root));
      root = path.join('external', root);
    } else {
      // The repository should be layed out in the parent directory
      // since bazel sets our working directory to the repository where the build is happening
      root = path.join('..', root);
    }
    if (!fs.existsSync('node_modules')) {
      // Bazel starts our process in the working directory of the current workspace
      // Since our mappings contain the workspace name, we want to be relative to the parent
      // directory
      symlink(root, 'node_modules');
    }
  } else {
    log_verbose('mkdir node_modules in ', process.cwd())
    fs.mkdirSync('node_modules');
    root = 'node_modules';
  }

  // Typically, cwd=foo, root=external/npm/node_modules, so we want links to be
  // ../../../../foo/path/to/package
  const symlinkRelativeTarget = path.relative(root, '..');
  process.chdir(root);

  // Now add symlinks to each of our first-party packages so they appear under the node_modules tree
  for (const m of Object.keys(modules)) {
    if (fs.existsSync(m)) {
      // If not in a sandbox, this file may already exist from the last bazel run of the linker
      log_verbose(`not symlinking '${m}' which already exists`);
      continue;
    }

    let target = path.join(symlinkRelativeTarget, modules[m]);
    symlink(target, m);
  }

  log_verbose('at the end cwd', process.cwd())
  log_verbose(`node_modules directory listing after linking:`);
  log_ls_r('.');
}

exports.main = main;

if (require.main === module) {
  process.exitCode = main(process.argv.slice(2));
}