/**
 * @fileoverview Creates a node_modules directory in the current working directory
 * and symlinks in the node modules needed to run a program.
 * This replaces the need for custom module resolution logic inside the process.
 */
const fs = require('fs');
const path = require('path');

function debug(...m) {
  if (!!process.env['VERBOSE_LOGS']) console.error('[link_node_modules.js]', ...m);
}

function ls_r(d) {
  for (const p of fs.readdirSync(d)) {
    const f = path.join(d, p);
    debug('  ', f);
    if (fs.statSync(f).isDirectory()) {
      ls_r(f);
    }
  }
}

function symlink(target, path) {
  debug(`symlink( ${path} -> ${target} )`);
  fs.symlinkSync(target, path);
}

function main(args) {
  if (!args || args.length < 1)
    throw new Error('link_node_modules.js requires one argument: modulesManifest path');

  const [modulesManifest] = args;
  let {root, modules} = JSON.parse(fs.readFileSync(modulesManifest));
  modules = modules || {};
  debug('read module manifest, node_modules root is', root, 'with first-party packages', modules);

  // First, symlink from a local `$PWD/node_modules` directory to the root of the third-party
  // installed node_modules (or create a node_modules directory if no root)

  if (!!root) {
    // Account for Bazel --legacy_external_runfiles
    if (fs.existsSync(path.join('external', root))) {
      debug('Found legacy_external_runfiles, switching root to', path.join('external', root));
      root = path.join('external', root);
    } else {
      // The repository should be layed out in the parent directory
      // since bazel sets our working directory to the repository where the build is happening
      root = path.join('..', root);
    }
    if (!fs.existsSync('node_modules')) {
      // Bazel starts our process in the working directory of the current workspace
      // Since our mappings contain the workspace name, we want to be relative to the parent
      // directory
      symlink(root, 'node_modules');
    }
  } else {
    fs.mkdirSync('node_modules');
    console.error('mkdir node_modules in ', process.cwd)
    root = 'node_modules';
  }

  // Typically, cwd=foo, root=external/npm/node_modules, so we want links to be
  // ../../../../foo/path/to/package
  const symlinkRelativeTarget = path.relative(root, '..');
  process.chdir(root);


  // Now add symlinks to each of our first-party packages so they appear under the node_modules tree
  for (const m of Object.keys(modules)) {
    if (fs.existsSync(m)) continue;

    let target = path.join(symlinkRelativeTarget, modules[m]);
    symlink(target, m);
  }
  debug('at the end cwd', process.cwd())
  ls_r('.');
}

exports.main = main;

if (require.main === module) {
  process.exitCode = main(process.argv.slice(2));
}